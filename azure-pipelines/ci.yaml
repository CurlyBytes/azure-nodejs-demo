name: $(BuildID)

trigger:
  branches:
    include:
    - fix/*
    - feat/*
    - main
  tags:
    include:
    - v*
  paths:
    exclude:
    - README.md

pr:
- main

pool:
  vmImage: 'ubuntu-latest'

schedules:
  - cron: "0 12 * * 0"
    displayName: Weekly Sunday build
    always: true
    branches:
      include:
      - main

variables:
- template: vars-global.yaml

stages:

# Tests Stage
# -----------
- stage: Tests
  displayName: Node.js - Tests
  condition: not(${{ variables.isTag }})
  jobs:
  - job: Tests
    steps:
    - template: step-debug.yaml

    - script: npm ci
      displayName: npm install

    - script: npm audit --audit-level=moderate
      displayName: npm audit (dev)
      continueOnError: true

    - script: npm audit --production --audit-level=high
      displayName: npm audit (prod)

    - script: npm run lint
      displayName: linter

    - script: npm run test
      displayName: tests


# Build Stage
# -----------
- stage: Build
  displayName: Docker - Build and Push
  condition: or(${{ variables.isTag }}, and(succeeded(), ${{ variables.isMain }}, ${{ variables.isTrustedCI }}))
  variables:
    - group: nodejs-demo-kv
  jobs:
  - job: Build
    steps:
    - template: step-debug.yaml

    - bash: |
        npm ci
        npm run compile-sass
        docker build -t $(dockerTag) .
      displayName: docker - build

    - task: SnykSecurityScan@0
      displayName: Snyk - security scan
      inputs:
        serviceConnectionEndpoint: 'snyk-api-connection'
        testType: 'container'
        dockerImageName: $(dockerTag)
        dockerfilePath: 'Dockerfile'
        monitorOnBuild: true
        failOnIssues: true

    # Note: about `docker login` & Security
    #
    # - Use case: We want to perform a security scan our docker image *before* pushing it
    #
    # - Problem:  Azure pipelines built in tasks can only do build _and_ push.
    #             Judging by source in github.com it is because it handles docker
    #             tagging convention, e.g. $(dockerRegistry)/$(imageName):$(imageTag)
    #             as if an engineer wouldn't know thatâ€¦ maybe they don't? ðŸ˜¬
    #
    # - Workaround: I prefer plain `docker login` anyway. Because we are deploying to App Service,
    #               registry admin access is enabled anyway.

    - bash: docker login $(dockerRegistry) --username $ACR_USERNAME --password $ACR_PASSWORD
      displayName: registry - login
      env:
        ACR_USERNAME: $(kv-acr-username)
        ACR_PASSWORD: $(kv-acr-password)

    - bash: docker push $(dockerTag)
      displayName: docker - push

    - bash: docker logout $(dockerRegistry)
      displayName: registry - logout

    - task: AzureCLI@2
      displayName: 'registry - lock image (prod)'
      condition: ${{ variables.isTag }}
      inputs:
        azureSubscription: ${{ variables.armConnection }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          az acr repository update -n $(dockerRegistry) -t $(imageName):$(imageTag) --write-enabled false